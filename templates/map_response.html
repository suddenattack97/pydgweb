<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>브이월드 WMTS 배경지도 사용하기 오픈레이어스 3버전 이상</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.1.0/ol.css">
<!-- <script src="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v6.5.0/build/ol.js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
<script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ol@v8.1.0/dist/ol.js"></script>
<style>
    .main-container {
        display: flex;
    }

    .left-section, .right-section {
        padding: 10px;
    }

    .left-section {
        flex: 1; /* occupies 1/3 of the space */
    }

    .right-section {
        flex: 2; /* occupies 2/3 of the space */
        background-color: #f0f0f0; /* optional: just to differentiate between left and right sections */
    }
</style>
</head>

<body>
    <div class="main-container">
        <div class="left-section">
            <div> CAR ID ▶
                <input type="text" id="car_id" name="car_id" style="width:30px; text-align:center;" value="1" placeholder="1" />
            </div>
            <br>
            <button id="dataset1" style="width:100px;height:50px;">Data Record</button>
            <button id="dataset2" style="width:100px;height:50px;">Data Reset</button>
            <br><br>
            <button id="map1" style="width:100px;height:50px;">MapType1</button>
            <button id="map2" style="width:100px;height:50px;">MapType2</button>
            <br><br>
        </div>
        <div class="right-section">
            <div id="map" style="width: 100%; height: 730px; left: 0px; top: 0px"></div>
        </div>
    </div>
    <div id="marker" style="width: 20px; height: 20px; background-color: red;"></div>
<script type="text/javascript">

    var style = [
        new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: 'white',
                width: 10
            })
        }),
        new ol.style.Style({
            stroke: new ol.style.Stroke({
            color: 'rgba(136, 247, 95, 1)',
            width: 6
            })
        })
    ];
    var vectorSource = new ol.source.Vector();
    var finalSource = new ol.source.Vector();
    var finalNewSource = new ol.source.Vector();
    var NewSource = new ol.source.Vector();
    var finalLineSource = new ol.source.Vector();

    // 지도 위에 도로 벡터 저장소
    var vectorLayer = new ol.layer.Vector({
        source: vectorSource,
        style : style
      });
      var finalLayer = new ol.layer.Vector({
        source: finalSource,
        style : new ol.style.Style({
          stroke: new ol.style.Stroke({
                  color: 'red',
                  width: 10
              })
          })
      });
      var finalNewLayer = new ol.layer.Vector({
        source: finalNewSource,
        style : new ol.style.Style({
          stroke: new ol.style.Stroke({
                  color: 'red',
                  width: 10
              })
          })
      });
      var NewLayer = new ol.layer.Vector({
        source: NewSource,
        style : new ol.style.Style({
          stroke: new ol.style.Stroke({
                  color: 'red',
                  width: 10
              })
          })
      });
      var finalLineLayer = new ol.layer.Vector({
          source: finalLineSource,
          style : new ol.style.Style({
            stroke: new ol.style.Stroke({
                    color: 'rgba(221, 153, 250, 1)',
                    width: 30
                })
            })
        });

    var Base = new ol.layer.Tile({
        name : "Base",
        source: new ol.source.XYZ({
            url: 'http://api.vworld.kr/req/wmts/1.0.0/F6342F62-1FE6-3AE7-A404-6B9E0583385C/Base/{z}/{y}/{x}.png'
        })
    }); // WMTS API 사용
    var olView = new ol.View({
        center: [14135262.366916759, 4512601.7000185],//좌표계 변환
        zoom: 12.7
    })// 뷰 설정
    var map = new ol.Map({
        layers: [Base,vectorLayer, finalLayer , finalNewLayer , NewLayer , finalLineLayer],
        target: 'map',
        view: olView
    });
    //map.getView().setMinZoom(12.7);
    //map.getView().setMaxZoom(18);

    // 지도의 'moveend' 이벤트를 사용하여 지도가 움직일 때마다 extent를 업데이트
    map.on('moveend', function() {
        var currentExtent = map.getView().calculateExtent(map.getSize());
        vectorLayer.setExtent(currentExtent);
        finalLayer.setExtent(currentExtent);
        finalNewLayer.setExtent(currentExtent);
        NewLayer.setExtent(currentExtent);
        finalLineLayer.setExtent(currentExtent);
    });

    /*
    var wms_title = '연속지적도';
    var wms_val = 'lp_pa_cbnd_bubun';
 
    var wms_tile = new ol.layer.Tile({
        name : "WMS_LAYER",
        source : new ol.source.TileWMS({
            url : "http://api.vworld.kr/req/wms?",
            params : {
                LAYERS : wms_val,
                STYLES : wms_val,
                CRS : "EPSG:900913",
                apikey : "F6342F62-1FE6-3AE7-A404-6B9E0583385C",
                DOMAIN : "http://loacalhost:4444",
                title : wms_title,
                FORMAT : "image/png",
                domain : "http://localhost"
            }
        })
    });
    map.addLayer(wms_tile);
    */
var data_record = 0;

map.on("click", function(evt) {
    if(data_record == 1){
        // 지도 클릭 이벤트 리스너 추가
        var coordinate = evt.coordinate;
        var car_id = $("#car_id").val();
        console.log('Clicked Coordinate:', coordinate);
        // AJAX를 사용하여 서버에 좌표 전송
        
        $.ajax({
            type: "POST",
            url: "/save-coordinate",  // 예: "https://yourserver.com/save-coordinate"
            data: {
                car_id : car_id,
                x: coordinate[0],
                y: coordinate[1]
            },
            success: function(response) {
                console.log('Coordinate saved successfully:', response);
            },
            error: function(error) {
                console.error('Error saving coordinate:', error);
            }
        });
    }
});

$("#dataset1").click(function() {
    if(data_record == 0) {
        data_record = 1;
        $("#dataset1").text("Recording");
        $("#dataset1").css('background','red');
        $("#dataset1").css('color','white');
    }else{
        data_record = 0;
        $("#dataset1").text("Data Record");
        $("#dataset1").css('background-color','buttonface');
        $("#dataset1").css('color','buttontext');
    }
});

$("#dataset2").click(function() {
    $.ajax({
        type: "POST",
        url: '/data_reset',
        data: {},
        success: function(response) {
            location.reload();
        },
        error: function(error) {
            console.error('Error loading dataset:', error);
        }
    });
});

$("#map1").click(function() {
    $(".ol-overlaycontainer").css('background-color','rgba(0, 0, 0, 0.8)');
    $(".ol-overlaycontainer").css('background-image','url({{ url_for("static", filename="lo.gif") }})');
    $(".ol-overlaycontainer").css('background-repeat','no-repeat');
    $(".ol-overlaycontainer").css('background-position','center center');

    $.ajax({
        type: "GET",
        url: "{{ url_for('static', filename='map_data3.geojson') }}",
        dataType: 'json',
        success: function(response){
            var format = new ol.format.GeoJSON();
            var features = format.readFeatures(response, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:3857'
            });
        // 지도 위에 도로 벡터 저장소
            vectorSource.clear();
            finalSource.clear();
            finalNewSource.clear();
            NewSource.clear();
            finalLineSource.clear();
            vectorSource.addFeatures(features);
            map.getView().setCenter([14136003.574816316,4511878.891130752]);
            map.getView().setZoom(12.7);

            sse();
        },complete : function(){
            $(".ol-overlaycontainer").css('background-color','');
            $(".ol-overlaycontainer").css('background-image','');
            $(".ol-overlaycontainer").css('background-repeat','no-repeat');
            $(".ol-overlaycontainer").css('background-position','center center');
        }
    });
});
$("#map2").click(function() {
    $(".ol-overlaycontainer").css('background-color','rgba(0, 0, 0, 0.8)');
    $(".ol-overlaycontainer").css('background-image','url({{ url_for("static", filename="lo.gif") }})');
    $(".ol-overlaycontainer").css('background-repeat','no-repeat');
    $(".ol-overlaycontainer").css('background-position','center center');
    $.ajax({
        type: "GET",
        url: "{{ url_for('static', filename='map_data2.geojson') }}",
        dataType: 'json',
        success: function(response){
            var format = new ol.format.GeoJSON();
            var features = format.readFeatures(response, {
            dataProjection: 'EPSG:4326',
            featureProjection: 'EPSG:3857'
            });
        // 지도 위에 도로 벡터 저장소
            vectorSource.clear();
            finalSource.clear();
            finalNewSource.clear();
            NewSource.clear();
            finalLineSource.clear();
            vectorSource.addFeatures(features);
            map.getView().setCenter([14136003.574816316,4511878.891130752]);
            map.getView().setZoom(14);
        },complete : function(){
            $(".ol-overlaycontainer").css('background-color','');
            $(".ol-overlaycontainer").css('background-image','');
            $(".ol-overlaycontainer").css('background-repeat','no-repeat');
            $(".ol-overlaycontainer").css('background-position','center center');
        }
    });
});
$("#map1").click();

function sse(){
    if (!!window.EventSource) {
        var source = new EventSource('/events');
    
        source.addEventListener('message', function(e) {
            var parsedData = JSON.parse(e.data); // e.data 전체를 파싱
            var newCoordinates = parsedData.coordinates; // 파싱된 데이터에서 coordinates 가져오기
            var dataType = parsedData.datatype; // 파싱된 데이터에서 dataType 가져오기
            console.log(dataType);
            if(e){
                if(vectorSource){
                    dataset(newCoordinates,dataType);  // 새로운 데이터를 지도에 추가
                }
            }
        }, false);
    
        source.addEventListener('open', function(e) {
            console.log("SSE 연결이 열렸습니다.");
        }, false);
    
        source.addEventListener('error', function(e) {
            if (e.readyState == EventSource.CLOSED) {
                console.log("SSE 연결이 종료되었습니다.");
            }
        }, false);
    } else {
        console.log("브라우저에서 SSE를 지원하지 않습니다.");
    }
    
}
var finalLineStyle = new ol.style.Style({
    stroke: new ol.style.Stroke({
        color: 'rgba(248, 124, 248, 1)',
        width: 10
    })
});

var first_flag = [] ;
var preCoord = [];
var newSegments = []; 
var newPoint = []; 
var lineFeatures = []; // 개별 라인 객체를 저장할 배열
var marker = [];
var loading_flag = 0;

var groupedCoordinates = {};

function dataset(coordinate,dataType) {
    // coordinate 배열을 순회하며 car_id 별로 좌표를 그룹화합니다.
    for (var i = 0; i < coordinate.length; i++) {
        var carId = coordinate[i]['car_id'];
        var point = [coordinate[i]['x_point'], coordinate[i]['y_point']];
    
        // 해당 car_id의 배열이 없으면 새로 생성합니다.
        if (!groupedCoordinates[carId]) {
            groupedCoordinates[carId] = [];
        }
    
        // 해당 car_id의 배열에 좌표를 추가합니다.
        groupedCoordinates[carId].push(point);
    }
    console.log(groupedCoordinates);
    // 각 car_id 별로 좌표를 순회하며 선을 그립니다.
    for (var carId in groupedCoordinates) {
        if(!marker[carId]){
            var marker_content= document.createElement("div"); // 오버레이 팝업설정 
            marker_content.innerHTML+="<div id='truck' style='margin-top:-30px; margin-left: -30px;' class=''>\n\
            <img style='-webkit-user-drag: none; width:52px !important; height:52px !important;' src='{{ url_for('static', filename='truck.png') }}'/></div>";

            marker[carId] = new ol.Overlay({
                id:carId,
                element:marker_content,
                stopEvent : false,
                dragging: true
            });
            map.addOverlay(marker[carId]);	
        }

        var carCoordinates = groupedCoordinates[carId];
        for (var i = 0; i < carCoordinates.length - 1; i++) {
            var lineCoordinates = carCoordinates[i];
            var lineCoordinates2 = carCoordinates[i + 1];
            
            var lineGeom = new ol.geom.LineString([lineCoordinates, lineCoordinates2]);
            var lineFeature = new ol.Feature({
                geometry: lineGeom
            });
            lineFeature.setStyle(finalLineStyle);  // 스타일 적용
            finalLineSource.addFeature(lineFeature);
        }
            
        if(marker[carId]){
            marker[carId].setPosition(groupedCoordinates[carId][groupedCoordinates[carId].length-1]);
        }   
    }
};

function getPoint(center,car_id){
    if(marker[car_id]){
        marker[car_id].setPosition(center);
    }   
};

function getDistance(point1, point2) {
    let dx = point2[0] - point1[0];
    let dy = point2[1] - point1[1];
    
    return Math.sqrt(dx * dx + dy * dy);
}

function getMidpointOfLine(lineString) {
    const coordinates = lineString.getGeometry().getCoordinates();
    const start = coordinates[0];
    const end = coordinates[coordinates.length - 1];

    const midX = (start[0] + end[0]) / 2;
    const midY = (start[1] + end[1]) / 2;

    return [midX, midY];
}

function splitLineStringByDistance(lineString, distance , car_id) {
    const coordinates = lineString.getGeometry().getCoordinates();
    newSegments[car_id] = [];
  
    for (let i = 0; i < coordinates.length - 1; i++) {
      let start = coordinates[i];
      let end = coordinates[i + 1];
  
      let segmentLength = getDistance(start, end);
      if (segmentLength <= distance) {
        newSegments[car_id].push([start, end]);
      } else {
        let numOfSubSegments = Math.ceil(segmentLength / distance);
        let fraction = 1 / numOfSubSegments;
  
        for (let j = 0; j < numOfSubSegments; j++) {
          let newStart = lineString.getGeometry().getCoordinateAt(j * fraction);
          let newEnd = lineString.getGeometry().getCoordinateAt((j + 1) * fraction);
  
          var lineGeom = new ol.geom.LineString([newStart , newEnd]);
          var lineFeature = new ol.Feature({
              geometry: lineGeom
          });
  
          newSegments[car_id].push(lineFeature);
        }
        
      }
    }
  
  };  

function getfootPoint(line,center){
    var lineCoordinates = line.getGeometry().getCoordinates();
    var minDistance = Infinity;
    var footPoint = null;
    for (var i = 0; i < lineCoordinates.length - 1; i++) {
        var segmentStart = lineCoordinates[i];
        var segmentEnd = lineCoordinates[i + 1];
        var foot = footOfPerpendicular(center, segmentStart, segmentEnd);
        var dist = getDistance(center, foot);
        if (dist < minDistance) {
            minDistance = dist;
            footPoint = foot;
        }
    }
    if (footPoint) {
        var pointFeature = new ol.Feature(new ol.geom.Point(footPoint));
        var pointStyle = new ol.style.Style({
            image: new ol.style.Circle({
                radius: 5,
                fill: new ol.style.Fill({
                    color: 'pink'
                })
            })
        });
        pointFeature.setStyle(pointStyle);

        //NewSource.addFeature(pointFeature);
    }
    return footPoint;
}

function footOfPerpendicular(point, segmentStart, segmentEnd) {
    var v = [segmentEnd[0] - segmentStart[0], segmentEnd[1] - segmentStart[1]];
    var w = [point[0] - segmentStart[0], point[1] - segmentStart[1]];
    
    var c1 = w[0]*v[0] + w[1]*v[1];
    
    if (c1 <= 0) return segmentStart;
    
    var c2 = v[0]*v[0] + v[1]*v[1];
    
    if (c2 <= c1) return segmentEnd;
    
    var b = c1 / c2;
    return [segmentStart[0] + b * v[0], segmentStart[1] + b * v[1]];
}

function pointToSegmentDistance(point, segmentStart, segmentEnd) {
    var v = [segmentEnd[0] - segmentStart[0], segmentEnd[1] - segmentStart[1]];
    var w = [point[0] - segmentStart[0], point[1] - segmentStart[1]];
    
    var c1 = w[0]*v[0] + w[1]*v[1];
    if (c1 <= 0) return getDistance(point, segmentStart);
    
    var c2 = v[0]*v[0] + v[1]*v[1];
    if (c2 <= c1) return getDistance(point, segmentEnd);
    
    var b = c1 / c2;
    var projection = [segmentStart[0] + b * v[0], segmentStart[1] + b * v[1]];
    
    return getDistance(point, projection);
}

function pointToLineDistance(point, lineCoordinates) {
    var minDistance = Infinity;
    for (var i = 0; i < lineCoordinates.length - 1; i++) {
        var segmentStart = lineCoordinates[i];
        var segmentEnd = lineCoordinates[i + 1];
        var dist = pointToSegmentDistance(point, segmentStart, segmentEnd);
        if (dist < minDistance) {
            minDistance = dist;
        }
    }
    return minDistance;
}

function findNearestLineFeature(point,car_id) {
    var minDistance = Infinity;
    var nearestLine = null;
    
    for (var i = 0; i < lineFeatures[car_id].length; i++) {
        var lineFeature = lineFeatures[car_id][i];
        var lineCoordinates = lineFeature.getGeometry().getCoordinates();
        var dist = pointToLineDistance(point, lineCoordinates);
        if (dist < minDistance) {
            minDistance = dist;
            nearestLine = lineFeature;
        }
    }
    return nearestLine;
}

</script>
</body>
</html>