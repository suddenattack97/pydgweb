<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>브이월드 WMTS 배경지도 사용하기 오픈레이어스 3버전 이상</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v8.1.0/ol.css">
<!-- <script src="https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v6.5.0/build/ol.js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
<script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ol@v8.1.0/dist/ol.js"></script>
<style>
    .main-container {
        display: flex;
    }

    .left-section, .right-section {
        padding: 10px;
    }

    .left-section {
        flex: 1; /* occupies 1/3 of the space */
    }

    .right-section {
        flex: 2; /* occupies 2/3 of the space */
        background-color: #f0f0f0; /* optional: just to differentiate between left and right sections */
    }
</style>
</head>

<body>
    <div class="main-container">
        <div class="left-section">
            <div> CAR ID ▶
                <input type="text" id="car_id" name="car_id" style="width:30px; text-align:center;" value="1" placeholder="1" />
            </div>
            <br>
            <button id="dataset1" style="width:100px;height:50px;">Data Record</button>
            <button id="dataset2" style="width:100px;height:50px;">Data Reset</button>
            <br><br>
            <br><br>
        </div>
        <div class="right-section">
            <div id="map" style="width: 100%; height: 730px; left: 0px; top: 0px"></div>
        </div>
    </div>
<script type="text/javascript">

    var style = [
        new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: 'white',
                width: 10
            })
        }),
        new ol.style.Style({
            stroke: new ol.style.Stroke({
            color: 'rgba(136, 247, 95, 1)',
            width: 6
            })
        })
    ];
    var vectorSource = new ol.source.Vector();
    var finalSource = new ol.source.Vector();
    var finalNewSource = new ol.source.Vector();
    var NewSource = new ol.source.Vector();
    var finalLineSource = new ol.source.Vector();

    // 지도 위에 도로 벡터 저장소
    var vectorLayer = new ol.layer.Vector({
        source: vectorSource,
        style : style,
        renderMode: 'webgl'
      });
      var finalLayer = new ol.layer.Vector({
        source: finalSource,
        style : new ol.style.Style({
          stroke: new ol.style.Stroke({
                  color: 'red',
                  width: 10
              })
          }),
          renderMode: 'webgl'
      });
      var finalNewLayer = new ol.layer.Vector({
        source: finalNewSource,
        style : new ol.style.Style({
          stroke: new ol.style.Stroke({
                  color: 'red',
                  width: 10
              })
          }),
          renderMode: 'webgl'
      });
      var NewLayer = new ol.layer.Vector({
        source: NewSource,
        style : new ol.style.Style({
          stroke: new ol.style.Stroke({
                  color: 'red',
                  width: 10
              })
          }),
          renderMode: 'webgl'
      });
      var finalLineLayer = new ol.layer.Vector({
          source: finalLineSource,
          style : new ol.style.Style({
            stroke: new ol.style.Stroke({
                    color: 'rgba(221, 153, 250, 1)',
                    width: 30
                })
            }),
            renderMode: 'webgl'
        });

    var Base = new ol.layer.Tile({
        name : "Base",
        source: new ol.source.XYZ({
            url: 'http://api.vworld.kr/req/wmts/1.0.0/F6342F62-1FE6-3AE7-A404-6B9E0583385C/Base/{z}/{y}/{x}.png'
        })
    }); // WMTS API 사용
    var olView = new ol.View({
        center: [14135262.366916759, 4512601.7000185],//좌표계 변환
        zoom: 12.7
    })// 뷰 설정
    var map = new ol.Map({
        layers: [Base,vectorLayer, finalLayer , finalNewLayer , NewLayer , finalLineLayer],
        target: 'map',
        view: olView,
        renderer: 'webgl'
    });
    map.getView().setMinZoom(12.7);
    map.getView().setMaxZoom(18);


    // 지도의 'moveend' 이벤트를 사용하여 지도가 움직일 때마다 extent를 업데이트
    map.on('moveend', function() {
        var currentExtent = map.getView().calculateExtent(map.getSize());
        vectorLayer.setExtent(currentExtent);
        finalLayer.setExtent(currentExtent);
        finalNewLayer.setExtent(currentExtent);
        NewLayer.setExtent(currentExtent);
        finalLineLayer.setExtent(currentExtent);
    });

var data_record = 0;

map.on("click", function(evt) {
    if(data_record == 1){
        // 지도 클릭 이벤트 리스너 추가
        var coordinate = evt.coordinate;
        var car_id = $("#car_id").val();
        console.log('Clicked Coordinate:', coordinate);
        // AJAX를 사용하여 서버에 좌표 전송
        
        $.ajax({
            type: "POST",
            async: false,
            url: "/save-coordinate",  // 예: "https://yourserver.com/save-coordinate"
            data: {
                car_id : car_id,
                x: coordinate[0],
                y: coordinate[1]
            },
            success: function(response) {
                console.log('Coordinate saved successfully:', response);
            },
            error: function(error) {
                console.error('Error saving coordinate:', error);
            }
        });
    }
});

$("#dataset1").click(function() {
    if(data_record == 0) {
        data_record = 1;
        $("#dataset1").text("Recording");
        $("#dataset1").css('background','red');
        $("#dataset1").css('color','white');
    }else{
        data_record = 0;
        $("#dataset1").text("Data Record");
        $("#dataset1").css('background-color','buttonface');
        $("#dataset1").css('color','buttontext');
    }
});

$("#dataset2").click(function() {
    $.ajax({
        type: "POST",
        url: '/data_reset',
        data: {},
        success: function(response) {
            location.reload();
        },
        error: function(error) {
            console.error('Error loading dataset:', error);
        }
    });
});

$.ajax({
    type: "GET",
    url: "{{ url_for('static', filename='map_data3.geojson') }}",
    dataType: 'json',
    success: function(response){
        var format = new ol.format.GeoJSON();
        var features = format.readFeatures(response, {
        dataProjection: 'EPSG:4326',
        featureProjection: 'EPSG:3857'
        });
    // 지도 위에 도로 벡터 저장소
        vectorSource.clear();
        finalSource.clear();
        finalNewSource.clear();
        NewSource.clear();
        finalLineSource.clear();
        vectorSource.addFeatures(features);
        map.getView().setCenter([14136003.574816316,4511878.891130752]);
        map.getView().setZoom(12.7);

        sse();
    },complete : function(){
        $(".ol-overlaycontainer").css('background-color','');
        $(".ol-overlaycontainer").css('background-image','');
        $(".ol-overlaycontainer").css('background-repeat','no-repeat');
        $(".ol-overlaycontainer").css('background-position','center center');
    }
});


function sse(){
    if (!!window.EventSource) {
        var source = new EventSource('/events_foot');
    
        source.addEventListener('message', function(e) {
            console.log(e);
            var newCoordinates = JSON.parse(e.data);
            if(e){
                if(vectorSource){
                    dataset(newCoordinates);  // 새로운 데이터를 지도에 추가
                }
            }
        }, false);
    
        source.addEventListener('open', function(e) {
            console.log("SSE 연결이 열렸습니다.");
        }, false);
    
        source.addEventListener('error', function(e) {
            if (e.readyState == EventSource.CLOSED) {
                console.log("SSE 연결이 종료되었습니다.");
            }
        }, false);
    } else {
        console.log("브라우저에서 SSE를 지원하지 않습니다.");
    }
    
}
var finalLineStyle = new ol.style.Style({
    stroke: new ol.style.Stroke({
        color: 'rgba(248, 124, 248, 1)',
        width: 10
    })
});

var first_flag = [] ;
var preCoord = [];
var newSegments = []; 
var newPoint = []; 
var lineFeatures = []; // 개별 라인 객체를 저장할 배열


function dataset(coordinate) {
    var currentIndex = 0;
    coordinate.forEach(function(item){
        var car_id = item.car_id;
        var xy_date = item.xydate;
        var center = [item.x_point , item.y_point]
        getPoint(center, car_id)
        currentIndex++;  // 다음 인덱스로 이동

        $.ajax({
            type: "POST",
            async: false,
            url: "/getfootPoint",  // 예: "https://yourserver.com/save-coordinate"
            contentType: 'application/json;charset=UTF-8',
            data: JSON.stringify({  // 데이터를 JSON 문자열로 변환
                car_id : car_id ,
                footPoint : newPoint[car_id],
                ori_x : center[0],
                ori_y : center[1]
            }),
            success: function(response) {
                console.log('Coordinate saved successfully:', response);
            },
            error: function(error) {
                console.error('Error saving coordinate:', error);
            }
        });

    });
};
async function getPoint(center, car_id) {
    return new Promise((resolve, reject) => {
        try {
            var featuresInExtent = vectorSource.getFeaturesInExtent(map.getView().calculateExtent(map.getSize()));
            // 라인 스타일 지정
            lineFeatures[car_id] = [];
            newPoint[car_id] = [];
            
            featuresInExtent.forEach(function(feature) {
                var coordinates = feature.getGeometry().getFlatCoordinates();
                for (var i = 0; i < coordinates.length - 1; i += 2) {
                    var lineCoordinates = [coordinates[i], coordinates[i + 1]];
                    var lineCoordinates2 = [coordinates[i+2], coordinates[i + 3]];
                    var lineGeom = new ol.geom.LineString([lineCoordinates , lineCoordinates2]);
                    var lineFeature = new ol.Feature({
                        geometry: lineGeom
                    });
                    lineFeatures[car_id].push(lineFeature);
                }
            });
            var nearestLine = findNearestLineFeature(center,car_id);
            if (nearestLine) {
                var footPoint = getfootPoint(nearestLine,center);
                if(first_flag[car_id]){
                    var lineGeom = new ol.geom.LineString([preCoord[car_id] , footPoint]);
                    var lineFeature = new ol.Feature({
                        geometry: lineGeom
                    });
                    
                    splitLineStringByDistance(lineFeature, 10, car_id);

                    //// ###############################  라인간의 선을 n빵 시키는 로직
                    newSegments[car_id].forEach(function(feature) {
                        if(feature.length > 1){
                            return true;
                        }
                        var center = getMidpointOfLine(feature);
                        var nearestLine = findNearestLineFeature(center, car_id);
                        if (nearestLine) {
                            var footPoint = getfootPoint(nearestLine,center);
                            newPoint[car_id].push(footPoint);
                        }
                    });
                    //// ###############################  라인간의 선을 n빵 시키는 로직
                    
                    //// ###############################   맨 앞 점과 잘라진 점을 이어붙인다.
                    preCoord[car_id] = footPoint;
                    //// ###############################   맨 끝 점과 잘라진 점을 이어붙인다.


                    //// ###############################   새로 도로 위 매칭된 수선의 발들을 모두 이어붙인다.
                    for (var i = 0; i < newPoint[car_id].length - 1; i++) {
                        var lineCoordinates = newPoint[car_id][i];
                        var lineCoordinates2 = newPoint[car_id][i+1];
                        var lineGeom = new ol.geom.LineString([lineCoordinates , lineCoordinates2]);
                        var lineFeature = new ol.Feature({
                            geometry: lineGeom
                        });
                    }
                    //// ###############################   새로 도로 위 매칭된 수선의 발들을 모두 이어붙인다.
                    
                }else{
                    preCoord[car_id] = footPoint;
                    first_flag[car_id] = true
                }
            }

            resolve();  // 작업이 성공적으로 완료되면 resolve를 호출합니다.
        } catch (error) {
            reject(error);  // 작업 중 오류가 발생하면 reject를 호출하여 오류를 반환합니다.
        }
    });
};

function getDistance(point1, point2) {
    let dx = point2[0] - point1[0];
    let dy = point2[1] - point1[1];
    
    return Math.sqrt(dx * dx + dy * dy);
}

function getfootPoint(line,center){
    var lineCoordinates = line.getGeometry().getCoordinates();
    var minDistance = Infinity;
    var footPoint = null;
    for (var i = 0; i < lineCoordinates.length - 1; i++) {
        var segmentStart = lineCoordinates[i];
        var segmentEnd = lineCoordinates[i + 1];
        var foot = footOfPerpendicular(center, segmentStart, segmentEnd);
        var dist = getDistance(center, foot);
        if (dist < minDistance) {
            minDistance = dist;
            footPoint = foot;
        }
    }
    return footPoint;
}

function getMidpointOfLine(lineString) {
    const coordinates = lineString.getGeometry().getCoordinates();
    const start = coordinates[0];
    const end = coordinates[coordinates.length - 1];

    const midX = (start[0] + end[0]) / 2;
    const midY = (start[1] + end[1]) / 2;

    return [midX, midY];
}

function footOfPerpendicular(point, segmentStart, segmentEnd) {
    var v = [segmentEnd[0] - segmentStart[0], segmentEnd[1] - segmentStart[1]];
    var w = [point[0] - segmentStart[0], point[1] - segmentStart[1]];
    
    var c1 = w[0]*v[0] + w[1]*v[1];
    
    if (c1 <= 0) return segmentStart;
    
    var c2 = v[0]*v[0] + v[1]*v[1];
    
    if (c2 <= c1) return segmentEnd;
    
    var b = c1 / c2;
    return [segmentStart[0] + b * v[0], segmentStart[1] + b * v[1]];
}


function splitLineStringByDistance(lineString, distance , car_id) {
    const coordinates = lineString.getGeometry().getCoordinates();
    newSegments[car_id] = [];
  
    for (let i = 0; i < coordinates.length - 1; i++) {
      let start = coordinates[i];
      let end = coordinates[i + 1];
  
      let segmentLength = getDistance(start, end);
      if (segmentLength <= distance) {
        newSegments[car_id].push([start, end]);
      } else {
        let numOfSubSegments = Math.ceil(segmentLength / distance);
        let fraction = 1 / numOfSubSegments;
  
        for (let j = 0; j < numOfSubSegments; j++) {
          let newStart = lineString.getGeometry().getCoordinateAt(j * fraction);
          let newEnd = lineString.getGeometry().getCoordinateAt((j + 1) * fraction);
  
          var lineGeom = new ol.geom.LineString([newStart , newEnd]);
          var lineFeature = new ol.Feature({
              geometry: lineGeom
          });
  
          newSegments[car_id].push(lineFeature);
        }
        
      }
    }
  
  }; 

function pointToSegmentDistance(point, segmentStart, segmentEnd) {
    var v = [segmentEnd[0] - segmentStart[0], segmentEnd[1] - segmentStart[1]];
    var w = [point[0] - segmentStart[0], point[1] - segmentStart[1]];
    
    var c1 = w[0]*v[0] + w[1]*v[1];
    if (c1 <= 0) return getDistance(point, segmentStart);
    
    var c2 = v[0]*v[0] + v[1]*v[1];
    if (c2 <= c1) return getDistance(point, segmentEnd);
    
    var b = c1 / c2;
    var projection = [segmentStart[0] + b * v[0], segmentStart[1] + b * v[1]];
    
    return getDistance(point, projection);
}

function pointToLineDistance(point, lineCoordinates) {
    var minDistance = Infinity;
    for (var i = 0; i < lineCoordinates.length - 1; i++) {
        var segmentStart = lineCoordinates[i];
        var segmentEnd = lineCoordinates[i + 1];
        var dist = pointToSegmentDistance(point, segmentStart, segmentEnd);
        if (dist < minDistance) {
            minDistance = dist;
        }
    }
    return minDistance;
}

function findNearestLineFeature(point,car_id) {
    var minDistance = Infinity;
    var nearestLine = null;
    
    for (var i = 0; i < lineFeatures[car_id].length; i++) {
        var lineFeature = lineFeatures[car_id][i];
        var lineCoordinates = lineFeature.getGeometry().getCoordinates();
        var dist = pointToLineDistance(point, lineCoordinates);
        if (dist < minDistance) {
            minDistance = dist;
            nearestLine = lineFeature;
        }
    }
    return nearestLine;
}

</script>
</body>
</html>